<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Compilers@NJUSE-Chapter04 Syntax Analysis | Rashawn's Blog</title><meta name="author" content="RashawnXue"><meta name="copyright" content="RashawnXue"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="引言语法分析器的作用  输入：词法分析器输出的词法单元序列 输出：语法树表示 语法分析器功能 验证输入源程序的合法性，输出良构程序的语法结构 对于病构的程序，能够报告语法错误，进行错误恢复   语法分析器的类型 通用型 自顶向下：通常处理LL文法（从左到右扫描字符） 自底向上：通常处理LR文法   类型检查，语义分析，翻译生成中间代码等往往和语法分析过程交错完成，实践中往往和语法分析放入一个模块，">
<meta property="og:type" content="article">
<meta property="og:title" content="Compilers@NJUSE-Chapter04 Syntax Analysis">
<meta property="og:url" content="http://rashawnxue.github.io/2023/04/18/courses/NJUSE/Compilers@NJUSE/Compilers-NJUSE-Chapter04/index.html">
<meta property="og:site_name" content="Rashawn&#39;s Blog">
<meta property="og:description" content="引言语法分析器的作用  输入：词法分析器输出的词法单元序列 输出：语法树表示 语法分析器功能 验证输入源程序的合法性，输出良构程序的语法结构 对于病构的程序，能够报告语法错误，进行错误恢复   语法分析器的类型 通用型 自顶向下：通常处理LL文法（从左到右扫描字符） 自底向上：通常处理LR文法   类型检查，语义分析，翻译生成中间代码等往往和语法分析过程交错完成，实践中往往和语法分析放入一个模块，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/icon/avatar-icon-square.png">
<meta property="article:published_time" content="2023-04-18T11:45:09.000Z">
<meta property="article:modified_time" content="2023-08-20T08:34:27.938Z">
<meta property="article:author" content="RashawnXue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/icon/avatar-icon-square.png"><link rel="shortcut icon" href="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/icon/avatar-icon-square.png"><link rel="canonical" href="http://rashawnxue.github.io/2023/04/18/courses/NJUSE/Compilers@NJUSE/Compilers-NJUSE-Chapter04/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Compilers@NJUSE-Chapter04 Syntax Analysis',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-20 16:34:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/icon/avatar-icon-square.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: url"><nav id="nav"><span id="blog-info"><a href="/" title="Rashawn's Blog"><img class="site-icon" src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/icon/avatar-icon-square.png"/><span class="site-name">Rashawn's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Compilers@NJUSE-Chapter04 Syntax Analysis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-18T11:45:09.000Z" title="发表于 2023-04-18 19:45:09">2023-04-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-20T08:34:27.938Z" title="更新于 2023-08-20 16:34:27">2023-08-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/COURSES/">COURSES</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/COURSES/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-NJUSE/">编译原理@NJUSE</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Compilers@NJUSE-Chapter04 Syntax Analysis"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="语法分析器的作用"><a href="#语法分析器的作用" class="headerlink" title="语法分析器的作用"></a>语法分析器的作用</h2><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/1.png" alt=""></p>
<ul>
<li>输入：词法分析器输出的词法单元序列</li>
<li>输出：语法树表示</li>
<li>语法分析器功能<ul>
<li>验证输入源程序的合法性，输出良构程序的语法结构</li>
<li>对于病构的程序，能够报告语法错误，进行错误恢复</li>
</ul>
</li>
<li>语法分析器的类型<ul>
<li>通用型</li>
<li>自顶向下：通常处理<strong>LL</strong>文法（从左到右扫描字符）</li>
<li>自底向上：通常处理<strong>LR</strong>文法</li>
</ul>
</li>
<li>类型检查，语义分析，翻译生成中间代码等往往和语法分析过程<strong>交错完成</strong>，实践中往往和语法分析放入一个模块，图上用“前端的其余部分”表示上述活动</li>
</ul>
<h2 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h2><p>一种用于描述程序设计语言语法的表示方法，能够自然地描述程序设计语言构造的<strong>层次化</strong>语法结构</p>
<ul>
<li>文法给出了一个程序设计语言的精确易懂的<strong>语法规约</strong></li>
<li>可以基于文法构造语法分析器，帮助确定源程序的语法结构 </li>
<li>语法结构有助于把源程序翻译为正确的目标代码</li>
<li>文法的扩展性，有助于迭代的语言演化</li>
</ul>
<h2 id="代表性文法"><a href="#代表性文法" class="headerlink" title="代表性文法"></a>代表性文法</h2><h3 id="LR文法类"><a href="#LR文法类" class="headerlink" title="LR文法类"></a>LR文法类</h3><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/2.png" alt=""></p>
<ul>
<li>该文法指明了运算符的结合性和优先级</li>
<li>各式的解释：<ul>
<li>$E$ 表示一组以 $+$ 分隔的项所组成的表达式</li>
<li>$T$ 表示一组以 $*$ 分隔的项所组成的表达式</li>
<li>$F$ 表示因子，可能是括号括起来的表达式，也可能是标识符$id$</li>
</ul>
</li>
<li>属于LR文法类，适用于自底向上的语法分析技术</li>
<li>是左递归的，不能用于自顶向下的语法分析</li>
</ul>
<h3 id="LL文法"><a href="#LL文法" class="headerlink" title="LL文法"></a>LL文法</h3><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/3.png" alt=""></p>
<ul>
<li>上面文法的无左递归版本，可用于自顶向下的语法分析</li>
</ul>
<h1 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h1><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/4.png" alt=""></p>
<ul>
<li>上下文无关文法(Context Free Grammar, CFG)</li>
<li>上下文无关文法是一种能够很好描述程序设计语言的表示方法</li>
</ul>
<h2 id="上下文无关文法的定义"><a href="#上下文无关文法的定义" class="headerlink" title="上下文无关文法的定义"></a>上下文无关文法的定义</h2><ul>
<li>一个CFG由以下几个部分构成<ul>
<li><strong>终结符号</strong><ul>
<li>组成串的基本符号，与“词法单元名字”同义</li>
<li>上例中，终结符号为关键字 $if$ 和 $else$ 以及左右括号</li>
</ul>
</li>
<li><strong>非终结符号</strong><ul>
<li>语法变量，表示特定串的集合</li>
<li>给出了语言的层次结构，这种层次结构是语法分析和翻译的关键</li>
<li>上例中，非终结符号为 $stmt$ 和 $expr$</li>
</ul>
</li>
<li>一个<strong>开始符号</strong><ul>
<li>某个特定的非终结符号，其表示的串集合是这个文法生成的语言</li>
</ul>
</li>
<li>一组<strong>产生式</strong> <ul>
<li>描述将终结符号和非终结符号组合成串的方法，由下列元素组成<ul>
<li>产生式左部（头）是一个非终结符号</li>
<li>符号 “ → ” ，有时用 $::=$ 代替箭头</li>
<li>一个由零个或多个终结符号与非终结符号组成的产生式<em>右部</em>（<em>体</em>）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="上下文有关文法与上下文无关文法"><a href="#上下文有关文法与上下文无关文法" class="headerlink" title="上下文有关文法与上下文无关文法"></a>上下文有关文法与上下文无关文法</h2><ul>
<li>什么是上下文？<ul>
<li>在应用一个产生式进行推导时，前后已经推导出的部分结果就是上下文</li>
<li>上下文无关的意思是，只要文法的定义里有某个产生式，不管一个非终结符前后的串是什么，就可以应用相应的产生式进行推导</li>
</ul>
</li>
<li>文法的分类<ul>
<li>上下文有关文法</li>
<li>上下文无关文法</li>
</ul>
</li>
</ul>
<h3 id="一个简单的上下文无关文法例子"><a href="#一个简单的上下文无关文法例子" class="headerlink" title="一个简单的上下文无关文法例子"></a>一个简单的上下文无关文法例子</h3><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/5.png" alt=""></p>
<ul>
<li>其中英文字母都是非终结符（SVO 分别表示主谓宾），汉字都是终结符</li>
<li>可推导出“天吃肉”。其（最左）推导过程为：Sent -&gt; SVO -&gt; 天VO -&gt; 天吃O -&gt; 天吃肉</li>
</ul>
<h3 id="一个简单的上下文有关文法例子"><a href="#一个简单的上下文有关文法例子" class="headerlink" title="一个简单的上下文有关文法例子"></a>一个简单的上下文有关文法例子</h3><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/6.png" alt=""></p>
<ul>
<li>其中英文字母都是非终结符（SVO 分别表示主谓宾），汉字都是终结符</li>
<li>可推导出“人吃饭”。过程：Sent -&gt; SVO -&gt; 人VO -&gt; 人吃O -&gt; 人吃饭</li>
</ul>
<h3 id="用于描述算术表达式的文法定义"><a href="#用于描述算术表达式的文法定义" class="headerlink" title="用于描述算术表达式的文法定义"></a>用于描述算术表达式的文法定义</h3><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/7.png" alt=""></p>
<h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><ul>
<li>产生式又可称为重写规则（Rewriting rule） </li>
<li>推导<ul>
<li>将待处理的串中的某个非终结符号替换为这个非终结符号的某个产生式的体</li>
<li>从开始符号出发，不断进行上面的替换，就可以得到文法的不同句型 </li>
</ul>
</li>
<li><p>推导的实例</p>
<ul>
<li>文法: E → -E | E+E | E*E | (E) | id</li>
<li>从E到-(id)的推导序列：E =&gt; -E =&gt; -(E) =&gt; -(id)</li>
</ul>
</li>
<li><p>推导的一般性定义</p>
<ul>
<li>如果$A\rightarrow \gamma$是一个产生式，那么$\alpha A \beta \Rightarrow \alpha \gamma \beta$</li>
<li>经过零步或者多步推导出：$\mathop{\Longrightarrow}\limits^{*}$<ul>
<li>对于任何串$\alpha$, $\alpha \mathop{\Longrightarrow}\limits^{*}\alpha$ </li>
<li>如果$\alpha \mathop{\Longrightarrow}\limits^{<em>} \beta$且$\beta \mathop{\Longrightarrow}\limits^{</em>} \gamma$，那么$\alpha \mathop{\Longrightarrow}\limits^{*} \gamma$ </li>
</ul>
</li>
<li>经过一步或者多步推导出：$\mathop{\Longrightarrow}\limits^{+}$ <ul>
<li>$\alpha \mathop{\Longrightarrow}\limits^{*} \beta$且$\alpha$不等于$\beta$等价于$\alpha \mathop{\Longrightarrow}\limits^{+} \beta$ </li>
</ul>
</li>
<li>最左(右)推导 <ul>
<li>符号：$\mathop{\Longrightarrow}\limits<em>{lm}^{*}, \mathop{\Longrightarrow}\limits</em>{rm}^{*}$</li>
</ul>
</li>
</ul>
</li>
<li><em>推导实例</em><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/8.png" alt=""></li>
</ul>
<h2 id="句型-句子-语言"><a href="#句型-句子-语言" class="headerlink" title="句型/句子/语言"></a>句型/句子/语言</h2><ul>
<li>句型（sentential form）<ul>
<li>如果$S \mathop{\Longrightarrow}\limits^{*} \alpha$，那么$\alpha$就是文法的一个句型</li>
<li>可能既包含非终结符，又包含终结符号；可以是空串</li>
</ul>
</li>
<li>句子（sentence）<ul>
<li>文法的句子就是不包含非终结符号的句型</li>
</ul>
</li>
<li>语言<ul>
<li>文法G的语言就是G的句子的集合，记为L(G)</li>
<li>$\omega$在L(G)中当且仅当$\omega$是G的句子，即$S \mathop{\Longrightarrow}\limits^{*} \omega$</li>
</ul>
</li>
</ul>
<h2 id="推导的问题"><a href="#推导的问题" class="headerlink" title="推导的问题"></a>推导的问题</h2><ul>
<li>从推导的角度看，语法分析的任务是：接受一个终结符号串作为输入，找出从文法的开始符号推导出这个串的方法</li>
<li>推导中可能遇到的<strong>两个问题</strong><ul>
<li>每一步替换哪个非终结符号？</li>
<li>若以这个非终结符号为头的产生式有多个，用哪个产生式的右部替换？</li>
</ul>
</li>
</ul>
<h2 id="非终结符号的替换顺序"><a href="#非终结符号的替换顺序" class="headerlink" title="非终结符号的替换顺序"></a>非终结符号的替换顺序</h2><ul>
<li>通常使用两种方式进行推导<ul>
<li>最左推导：总是选择每个句型的最左非终结符号。记作$\mathop{\Longrightarrow}\limits_{lm}$</li>
<li>最右推导：总是选择最右边的非终结符号。记作$\mathop{\Longrightarrow}\limits_{rm}$</li>
</ul>
</li>
<li>每个最左推导步骤可以写成 $\omega A \gamma \mathop{\Longrightarrow}\limits_{lm} \omega \delta \gamma$<ul>
<li>应用产生式: $A \rightarrow \delta$</li>
</ul>
</li>
<li>如果$\alpha$经过最左推导得到$\beta$，记作$\alpha \mathop{\Longrightarrow}\limits_{lm}^{*} \beta$</li>
<li>最左句型：S是文法G的识别符号，如果$S \mathop{\Longrightarrow}\limits_{lm}^{*} \alpha$ ，则$\alpha$是G的最左句型</li>
<li>最右推导也有类似的定义。最右推导有时也称为<strong>规范推导</strong></li>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/9.png" alt=""><ul>
<li>此例中第一行为最左推导，第二行为最右推导</li>
</ul>
</li>
</ul>
<h2 id="语法分析树"><a href="#语法分析树" class="headerlink" title="语法分析树"></a>语法分析树</h2><ul>
<li>推导的图形表示形式<ul>
<li>根结点的标号是文法的开始符号</li>
<li>每个叶子结点的标号是非终结符号、终结符号或$\epsilon$</li>
<li>每个内部节点的标号是非终结符号</li>
<li>每个内部结点表示某个产生式的一次应用<ul>
<li>内部结点的标号为产生式头，结点的子结点从左到右是产生式的体</li>
</ul>
</li>
</ul>
</li>
<li>有时允许树的根不是开始符号（对应于某个短语）</li>
<li>树的叶子组成的序列是根的文法符号的句型</li>
<li>一棵分析树可对应多个推导序列，但是<strong>分析树和最左（右）推导序列之间具有一一对应关系</strong></li>
</ul>
<hr>
<ul>
<li>推导的图形表示形式，树上看不出来推导的顺序</li>
<li>能够反映串的语法层次结构</li>
<li>语法分析树<ul>
<li>内部节点：对应于一个非终结符号</li>
<li>子节点：对应于其父节点为头的产生式体</li>
<li>叶子节点：可以是终结符号或非终结符号，从左到右排列可以得到一个句型，称为这棵树的结果<br><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/10.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="推导和语法树"><a href="#推导和语法树" class="headerlink" title="推导和语法树"></a>推导和语法树</h2><ul>
<li>考虑任意的推导$\alpha<em>{1} \Rightarrow \alpha</em>{2} \Rightarrow…\Rightarrow \alpha<em>{n}$，其中$\alpha</em>{1}$是单个非终结符$A$</li>
<li>对于推导中的每个句型$\alpha<em>{i}$ ，我们都可以构造出一个结果为$\alpha</em>{i}$的语法树<br><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/11.png" alt=""></li>
<li>上例的推导过程<img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/12.png" alt=""></li>
</ul>
<h2 id="二义性文法"><a href="#二义性文法" class="headerlink" title="二义性文法"></a>二义性文法</h2><ul>
<li>如果一个文法可以为一个句子生成多棵不同的语法 分析树，则该文法为二义性文法<img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/13.png" alt=""></li>
<li>通常情况下，我们需要无二义性的文法</li>
</ul>
<h2 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h2><ul>
<li>程序设计语言的文法通常都应该是无二义性的<ul>
<li>否则就会导致一个程序有多种“正确”的解释</li>
<li>如上例(a)图按照常规运算优先级处理了，而(b)则没有</li>
</ul>
</li>
<li>但有些二义性的情况可以方便文法或语法分析器的设计<ul>
<li>需要<strong>消二义性规则</strong>来剔除不要的语法分析树</li>
<li>比如：先乘除后加减</li>
</ul>
</li>
</ul>
<h2 id="文法及其生成的语言"><a href="#文法及其生成的语言" class="headerlink" title="文法及其生成的语言"></a>文法及其生成的语言</h2><ul>
<li>语言是由文法的开始符号出发，能够推导得到的所有句子的集合<img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/14.png" alt=""></li>
</ul>
<h2 id="验证文法生成的语言"><a href="#验证文法生成的语言" class="headerlink" title="验证文法生成的语言"></a>验证文法生成的语言</h2><ul>
<li>验证文法G生成语言L可以帮助我们了解文法可以生成什么样的语言</li>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/15.png" alt=""></li>
</ul>
<h2 id="词法分析与语法分析"><a href="#词法分析与语法分析" class="headerlink" title="词法分析与语法分析"></a>词法分析与语法分析</h2><ul>
<li>上下文无关文法和正则表达式</li>
<li>正则表达式 → 词法</li>
<li>上下文无关文法 → 语法</li>
</ul>
<h3 id="二者比较"><a href="#二者比较" class="headerlink" title="二者比较"></a>二者比较</h3><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/16.png" alt=""></p>
<ul>
<li>文法比正则表达式描述能力更强</li>
<li>正则表达式描述词法单元比较简洁</li>
<li>基于正则表达式构造的词法分析器效率更高</li>
<li>正则表达式适合描述词法结构，文法适合描述嵌套结构</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul>
<li>文法的类别，Chomsky文法类</li>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/17.png" alt=""></li>
</ul>
<h2 id="上下文无关文法和正则表达式✨"><a href="#上下文无关文法和正则表达式✨" class="headerlink" title="上下文无关文法和正则表达式✨"></a>上下文无关文法和正则表达式✨</h2><ul>
<li>上下文无关文法的表达能力更强<ul>
<li>证明：<ul>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/18.png" alt=""></li>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/19.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>每个正则表达式都可以用一个上下文无关文法来描述，反之不成立</li>
<li>每个正则语言都是一个上下文无关语言，反之不成立</li>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/20.png" alt=""></li>
</ul>
<h1 id="文法的设计"><a href="#文法的设计" class="headerlink" title="文法的设计"></a>文法的设计</h1><ul>
<li>程序设计语言所需要的文法<ul>
<li>上下文无关文法足够用来描述语法吗？<ul>
<li>标识符必须先声明后使用</li>
</ul>
</li>
<li>语法分析器能够完全按照上下文无关文法来构造吗？<ul>
<li>二义性、左递归的文法可能给语法分析器造成很大麻烦</li>
</ul>
</li>
</ul>
</li>
<li>可以怎么做？<ul>
<li>改造语法分析器，添加语义规则，使它可以做得更多</li>
<li>改造上下文无关文法，消除二义性和左递归</li>
</ul>
</li>
<li>在进行高效的语法分析之前，需要对文法做以下处理<ul>
<li>消除二义性<ul>
<li>文法的二义性：文法可以为一个句子生成多颗不同的树</li>
</ul>
</li>
<li>消除左递归<ul>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/21.png" alt=""></li>
</ul>
</li>
<li>提取左公因子</li>
</ul>
</li>
</ul>
<h2 id="消除文法的二义性"><a href="#消除文法的二义性" class="headerlink" title="消除文法的二义性"></a>消除文法的二义性</h2><ul>
<li>二义性实例<img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/22.png" alt=""></li>
<li>一些二义性文法可以被改成等价的无二义性的文法</li>
<li>例子<img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/23.png" alt=""></li>
<li>改写文法，基本思想: 在一个then和一个else之间出现的语句必须是“已匹配的”。也就是说then和else中间的语句不能以一个尚未匹配的then结尾</li>
<li>解决方案：引入新的非终结符号matched_stmt，用来区分是否是成对的then/else<img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/24.png" alt=""></li>
<li>注<ul>
<li>二义性的消除方法没有规律可循</li>
<li>通常并不是通过改变文法来消除二义性</li>
</ul>
</li>
</ul>
<h2 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h2><ul>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/25.png" alt=""></li>
</ul>
<h2 id="立即左递归的消除"><a href="#立即左递归的消除" class="headerlink" title="立即左递归的消除"></a>立即左递归的消除</h2><ul>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/26.png" alt=""></li>
<li>示例<img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/27.png" alt=""></li>
</ul>
<h2 id="消除多步左递归"><a href="#消除多步左递归" class="headerlink" title="消除多步左递归"></a>消除多步左递归</h2><ul>
<li>消除立即左递归的方法并不能消除因为两步或多步推导而产生的左递归</li>
</ul>
<h3 id="消除算法"><a href="#消除算法" class="headerlink" title="消除算法"></a>消除算法</h3><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/28.png" alt=""></p>
<h3 id="通用的左递归消除方法"><a href="#通用的左递归消除方法" class="headerlink" title="通用的左递归消除方法"></a>通用的左递归消除方法</h3><ul>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/29.png" alt=""></li>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/30.png" alt=""></li>
<li>示例<img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/31.png" alt=""></li>
</ul>
<h2 id="提取左公因子"><a href="#提取左公因子" class="headerlink" title="提取左公因子"></a>提取左公因子</h2><ul>
<li>在推导的时候，不知道该如何选择（自顶向下算法会详细描述）</li>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/32.png" alt=""></li>
</ul>
<h3 id="提取左公因子算法"><a href="#提取左公因子算法" class="headerlink" title="提取左公因子算法"></a>提取左公因子算法</h3><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/33.png" alt=""></p>
<h2 id="非上下文无关语言的构造"><a href="#非上下文无关语言的构造" class="headerlink" title="非上下文无关语言的构造"></a>非上下文无关语言的构造</h2><ul>
<li>抽象语言 L1={wcw | w在(a|b)*中}</li>
<li>这个语言不是上下文无关的语言</li>
<li>它抽象地表示了C或者Java中“标识符先声明后使用”的规则<ul>
<li>说明了C/Java这些语言不是上下文无关语言，不能使用上下文无关文法描述</li>
<li>通常用上下文无关文法描述其基本结构，不能用文法描述的特性在语义分析阶段完成。原因是<strong>上下文无关文法具有高效的处理算法</strong></li>
</ul>
</li>
</ul>
<h1 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h1><h2 id="自顶向下分析技术"><a href="#自顶向下分析技术" class="headerlink" title="自顶向下分析技术"></a>自顶向下分析技术</h2><ul>
<li>自顶向下分析可以被看作是为输入串构造语法分析树的问题，也可以看作一个寻找输入串的最左推导的过程</li>
<li>问题<ul>
<li>在推导的每一步，对非终结符号A，应用哪个产生式，以可能产生于输入串相匹配的终结符号串</li>
</ul>
</li>
</ul>
<h2 id="自顶向下语法分析-1"><a href="#自顶向下语法分析-1" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h2><ul>
<li>问题：对于非终结符号A，选择哪一个产生式</li>
<li>一种<strong>通用</strong>的<strong>递归下降</strong>分析框架<ul>
<li>由一组过程组成，每个非终结符号对应一个过程</li>
<li>程序的执行从开始符号对应的过程开始</li>
<li>每个过程的功能是：选择一个产生式体，扫描相应的句子。若遇到非终结符号，调用该符号对应的过程<img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/34.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="递归下降过程"><a href="#递归下降过程" class="headerlink" title="递归下降过程"></a>递归下降过程</h2><ul>
<li>可能需要回溯</li>
<li>回溯显然是笨方法</li>
</ul>
<h2 id="预测分析法简介"><a href="#预测分析法简介" class="headerlink" title="预测分析法简介"></a>预测分析法简介</h2><ul>
<li>试图从开始符号推导出输入符号串</li>
<li>以开始符号作为初始的当前句型</li>
<li>每次为最左边的非终结符号选择适当的产生式<ul>
<li>通过查看下一个输入符号来选择这个产生式</li>
<li>有多个可能的产生式时预测分析法无能为力</li>
</ul>
</li>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/35.png" alt=""></li>
<li>需要提取公因子</li>
</ul>
<h2 id="预测分析技术"><a href="#预测分析技术" class="headerlink" title="预测分析技术"></a>预测分析技术</h2><ul>
<li>一种确定性的、无回溯的分析技术</li>
<li>在每一步选择正确的产生式</li>
<li>通过在输入中向前看固定多个符号来选择正确的产生式</li>
<li>通常情况下，我们只需要向前看一个符号</li>
<li>递归下降分析一般只适合于每个子表达式的第一个终结符能够为产生式选择提供足够信息的那些文法</li>
<li>给出两个与文法相关的两个函数<ul>
<li>FIRST</li>
<li>FOLLOW</li>
</ul>
</li>
<li>基于上述两个函数，可以根据下一个输入符号来选择应用哪个产生式</li>
</ul>
<h2 id="FIRST和FOLLOW"><a href="#FIRST和FOLLOW" class="headerlink" title="FIRST和FOLLOW"></a>FIRST和FOLLOW</h2><ul>
<li>在自顶向下的分析技术中，通常使用向前看几个符号来唯一地确定产生式（这里假定只看一个符号）</li>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/36.png" alt=""></li>
<li>$FIRST(\alpha)$<ul>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/37.png" alt=""></li>
</ul>
</li>
<li>$FOLLOW(A)$<ul>
<li>可能在某些句型中紧跟在A右边的终结符号的集合<img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/38.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="FIRST-alpha"><a href="#FIRST-alpha" class="headerlink" title="$FIRST(\alpha)$"></a>$FIRST(\alpha)$</h2><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/39.png" alt=""></p>
<h3 id="First的计算"><a href="#First的计算" class="headerlink" title="First的计算"></a>First的计算</h3><ul>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/40.png" alt=""></li>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/41.png" alt=""></li>
</ul>
<h2 id="FOLLOW-函数"><a href="#FOLLOW-函数" class="headerlink" title="$FOLLOW$函数"></a>$FOLLOW$函数</h2><ul>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/42.png" alt=""></li>
</ul>
<h3 id="FOLLOW计算"><a href="#FOLLOW计算" class="headerlink" title="FOLLOW计算"></a>FOLLOW计算</h3><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/43.png" alt=""></p>
<h2 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h2><ul>
<li>LL(1)文法，第一个L表示自左向右扫描，第二个L指产生最左推导，而1则表示向前看一个输入符号</li>
<li>LL(1)文法可以利用不回溯的确定性的预测分析技术，因为只需要检查当前输入符号就可以为一个非终结符号选择正确的产生式</li>
<li>定义：对于文法的任意两个不同的产生式A→α|β<ul>
<li>不存在终结符号a使得α和β都可以推导出以a开头的串</li>
<li>α和β最多只有一个可以推导出空串</li>
<li>如果β可以推导出空串，那么α不能推导出以FOLLOW 中任何终结符号开头的串</li>
</ul>
</li>
<li>等价于<img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/44.png" alt=""></li>
<li>对于LL(1)文法，可以在自顶向下分析过程中，根据当前输入符号来确定使用的产生式</li>
</ul>
<h2 id="LL-1-文法的预测分析技术"><a href="#LL-1-文法的预测分析技术" class="headerlink" title="LL(1)文法的预测分析技术"></a>LL(1)文法的预测分析技术</h2><ul>
<li>LL(1)文法 ==&gt;预测分析表</li>
<li>将First和Follow集合中的信息放入一个预测分析表M[A,a]，该预测表告诉我们当非终结符号为A，当前输入符号为a时，要选择哪条产生式</li>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/45.png" alt=""></li>
</ul>
<h2 id="预测分析表构造"><a href="#预测分析表构造" class="headerlink" title="预测分析表构造"></a>预测分析表构造</h2><ul>
<li>输入：文法G</li>
<li>输出：预测分析表M</li>
<li>方法：对于文法G的每个产生式A→α，进行如下处理<ul>
<li>对于First(α)中的每个终结符号a，将A→α加入到M[A,a]</li>
<li>如果$\epsilon$在First(α)中，那么对于Follow(A)中的每个终结符号b，将A→α加入到M[A,b]中</li>
<li>如果$\epsilon$在First(α)中，且$在Follow(A)中，将A → α加入到 M[A,$]中 ◼ </li>
</ul>
</li>
<li>完成上述操作后，若M[A,a]中没有产生式，填为Error</li>
</ul>
<h2 id="预测分析方法"><a href="#预测分析方法" class="headerlink" title="预测分析方法"></a>预测分析方法</h2><ul>
<li>对于任何文法G，都可以构造预测分析表</li>
<li>对于LL(1)文法，预测表中每个条目都唯一地指定了一个产生式，或者标明Error</li>
</ul>
<h2 id="二义性文法的预测分析表"><a href="#二义性文法的预测分析表" class="headerlink" title="二义性文法的预测分析表"></a>二义性文法的预测分析表</h2><ul>
<li>对于某些文法，表中可能会有一些多重定义的条目，比如左递归或二义性文法</li>
</ul>
<h2 id="非递归的预测分析"><a href="#非递归的预测分析" class="headerlink" title="非递归的预测分析"></a>非递归的预测分析</h2><ul>
<li>在自顶向下分析的过程中，我们总是<ul>
<li>匹配掉句型中左边的所有终结符号</li>
<li>对于最左边的非终结符号，我们选择适当的产生式展开</li>
<li>匹配成功的终结符号不会再被考虑，因此我们只需要记住句型的余下部分，以及尚未匹配的输入终结符号串</li>
<li>由于展开的动作总是发生在余下部分的左端， 我们可以用<strong>栈</strong>来存放这些符号</li>
</ul>
</li>
<li>分析处理过程<ul>
<li>初始化时，栈中仅包含开始符号</li>
<li>如果栈顶元素是终结符号，那么进行匹配</li>
<li>如果栈顶元素是非终结符号<ul>
<li>使用预测分析表来<strong>选择</strong>适当的产生式</li>
<li>在栈顶用产生式右部<strong>替换</strong>产生式左部</li>
</ul>
</li>
<li>对所有文法的预测分析都可以共用同样的驱动程序</li>
</ul>
</li>
</ul>
<h3 id="非递归的预测分析技术"><a href="#非递归的预测分析技术" class="headerlink" title="非递归的预测分析技术"></a>非递归的预测分析技术</h3><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/46.png" alt=""></p>
<ul>
<li>文法符号栈</li>
<li>输入缓冲区</li>
<li>控制程序<ul>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/47.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="分析表驱动的预测分析器"><a href="#分析表驱动的预测分析器" class="headerlink" title="分析表驱动的预测分析器"></a>分析表驱动的预测分析器</h3><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/48.png" alt=""></p>
<ul>
<li>性质1：如果栈中的符号序列为<strong>α</strong>，而w‘是已经被读入的部分输入，w’是尚未处理的输入，那么<ul>
<li>S推导出wα</li>
<li>我们试图从α推导出余下的输入终结符号串w’</li>
</ul>
</li>
<li>预测分析程序使用M[X,a]来扩展X，将此产生式的右部按倒序压入栈中</li>
<li>请注意：这样的操作使得分析过程中性质1得到保持</li>
</ul>
<h3 id="表驱动的非递归的预测语法分析"><a href="#表驱动的非递归的预测语法分析" class="headerlink" title="表驱动的非递归的预测语法分析"></a>表驱动的非递归的预测语法分析</h3><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/49.png" alt=""></p>
<ul>
<li>输入：一个串w，文法G的预测分析表M</li>
<li>输出：如果w在L(G)中，输出w的一个最左推导；否则报错</li>
<li>方法：初始化输入缓冲区为w$, 栈顶是G的开始符号S， 下面是$</li>
</ul>
<h1 id="自底向上语法分析"><a href="#自底向上语法分析" class="headerlink" title="自底向上语法分析"></a>自底向上语法分析</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>为一个输入串构造语法分析树的过程</li>
<li>从叶子（输入串中的终结符号，将位于分析树的底端）开始，向上到达根结点</li>
<li>重要的自底向上语法分析的通用框架<ul>
<li>移入-归约</li>
</ul>
</li>
<li>LR：最大的可以构造出移入-归约语法分析器的语法类</li>
</ul>
<h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><ul>
<li>Bottom-Up Parsing<ul>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/50.png" alt=""></li>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/51.png" alt=""></li>
</ul>
</li>
<li>Bottom-up parsing – 将一个串w归约为文法符号的过程</li>
<li>在每一步的归约中，一个与某产生式体相匹配的特定子串被替换为该产生式头部的非终结符号，一次归约实质上是一个推导的反向操作</li>
</ul>
<h4 id="归约的例子"><a href="#归约的例子" class="headerlink" title="归约的例子"></a>归约的例子</h4><ul>
<li>id * id的归约过程<ul>
<li>id <em> id ，F </em> id，T <em> id，T </em> F，T，E</li>
</ul>
</li>
<li>对于句型T * id，有两个子串和某产生式右部匹配<ul>
<li>T是E → T的右部</li>
<li>id是F → id的右部</li>
<li>为什么选择将id归约为F，而不是将T归约为E？<ul>
<li>T归约为E之后，E * id不再是句型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h3><ul>
<li>自底向上分析的过程也是规约的过程</li>
<li>规约的问题：<ul>
<li>选择哪部分进行归约? </li>
<li>应用哪个产生式进行归约?</li>
</ul>
</li>
</ul>
<h4 id="回顾：句型-句子-语言"><a href="#回顾：句型-句子-语言" class="headerlink" title="回顾：句型/句子/语言"></a>回顾：句型/句子/语言</h4><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/52.png" alt=""></p>
<h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><ul>
<li>最右句型γ的一个句柄<ul>
<li>满足下述条件的产生式A→β及串β在γ中出现的位置</li>
<li>条件：将这个位置上的β替换为A之后得到的串是γ的某个最右推导序列中出现在位于γ之前的最右句型</li>
</ul>
</li>
<li>通俗地说<ul>
<li>句柄是最右推导的反向过程中被规约的那些部分</li>
</ul>
</li>
<li>句柄的作用<ul>
<li>对句柄的规约，代表了相应的最右推导中的一个反向步骤</li>
</ul>
</li>
<li>句柄是<strong>最右推导</strong>的<strong>反向</strong>过程中<strong>被规约</strong>的那些部分</li>
</ul>
<h3 id="句柄剪枝"><a href="#句柄剪枝" class="headerlink" title="句柄剪枝"></a>句柄剪枝</h3><ul>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/53.png" alt=""><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/54.png" alt=""></li>
<li>注意：<ul>
<li>归约前后都是最右句型</li>
<li>和某个产生式匹配的最左子串不一定是句柄</li>
<li>无二义性的文法，其每个最右句型都有且只有一个句柄</li>
</ul>
</li>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/55.png" alt=""></li>
</ul>
<h2 id="移入-归约语法分析框架"><a href="#移入-归约语法分析框架" class="headerlink" title="移入-归约语法分析框架"></a>移入-归约语法分析框架</h2><ul>
<li>一种自底向上的分析形式</li>
<li>使用一个栈保存文法符号，一个输入缓冲区存放将要进行分析的剩余符号</li>
<li>初始栈： $ 初始输入 w$</li>
<li>对输入串的一次从左到右的扫描过程中，语法分析器将零个或多个输入符号移到栈的顶端，直到它可以<strong>对栈顶的一个文法符号串</strong>进行<strong>归约</strong>为止。它将归约为某个产生式的头。不断重复这个循环，直到它检测到一个语法错误，或者栈中包含了开始符号且输入缓冲区为空</li>
<li>分析成功时： 栈 $ S, 输入 $</li>
<li>可行性分析：<strong>句柄总是出现在栈的顶端</strong>，绝不会出现在栈的中间<ul>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/56.png" alt=""></li>
<li>语法分析器进行一次归约以后，都必须接着移入零个或多个符号才能在栈顶找到下一个句柄</li>
<li>不需要去栈中间去寻找句柄</li>
</ul>
</li>
</ul>
<h3 id="移入-归约分析技术"><a href="#移入-归约分析技术" class="headerlink" title="移入-归约分析技术"></a>移入-归约分析技术</h3><ul>
<li>使用一个栈来保存归约/扫描移入的文法符号</li>
<li>栈中符号（从底向上）和待扫描的符号组成了一个最右句型</li>
<li>开始时刻：栈中只包含$，而输入为w$</li>
<li>成功结束时刻：栈中$S，而输入$</li>
<li>在分析过程中，不断地移入符号，并在识别到句型时进行归约</li>
</ul>
<h3 id="主要分析动作"><a href="#主要分析动作" class="headerlink" title="主要分析动作"></a>主要分析动作</h3><ul>
<li>移入：将下一个输入符号移动到栈顶</li>
<li>归约：将句柄归约为相应的非终结符号<ul>
<li>句柄总是在栈顶</li>
<li>具体操作时弹出句柄，压入被归约到的非终结符号</li>
</ul>
</li>
<li>接受：宣布分析过程成功完成</li>
<li>报错：发现语法错误，调用错误恢复子程序</li>
</ul>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><h3 id="移进-归约冲突"><a href="#移进-归约冲突" class="headerlink" title="移进/归约冲突"></a>移进/归约冲突</h3><ul>
<li>移入-归约技术并不能处理所有上下文无关文法</li>
<li>某些上下文无关文法（比如二义性文法）<ul>
<li>移入/归约冲突：栈中的内容和接下来的k个输入符号，都不能确定进行移入还是归约操作 (不能确定是否是句柄)</li>
<li>归约/归约冲突：存在多个可能的归约到不同非终结符号的归约(不能确定句柄归约到那个非终结符号)<br><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/57.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="归约-归约冲突"><a href="#归约-归约冲突" class="headerlink" title="归约/归约冲突"></a>归约/归约冲突</h3><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/58.png" alt=""></p>
<h3 id="解决冲突问题"><a href="#解决冲突问题" class="headerlink" title="解决冲突问题"></a>解决冲突问题</h3><ul>
<li>让词法分析区分id和procid</li>
<li>用[]表示数组，用()表示函数 </li>
<li>…… </li>
<li>但是并不能完全解决冲突问题</li>
<li>有一类文法可以解决句柄查找及归约唯一性的问题</li>
</ul>
<h1 id="LR语法分析技术"><a href="#LR语法分析技术" class="headerlink" title="LR语法分析技术"></a>LR语法分析技术</h1><ul>
<li>LR(k)的语法分析概念<ul>
<li>L表示最左扫描，R表示反向构造出最右推导</li>
<li>k表示最多向前看k个符号</li>
</ul>
</li>
<li>当k的数量增大时，相应的语法分析器的规模急剧增大<ul>
<li>K=2时，程序设计语言的语法分析器的规模通常非常庞大</li>
<li>当k=0、1时已经可以解决很多语法分析问题， 因此具有实践意义</li>
<li>因此，我们只考虑k&lt;=1的情况</li>
</ul>
</li>
</ul>
<h2 id="LR语法分析器的优点"><a href="#LR语法分析器的优点" class="headerlink" title="LR语法分析器的优点"></a>LR语法分析器的优点</h2><ul>
<li>表格驱动<ul>
<li>虽然手工构造表格工作量大，但表格可以自动生成</li>
</ul>
</li>
<li>对于几乎所有的程序设计语言，只要写出上下文无关文法，就能够构造出识别该构造的LR语法分析器</li>
<li>最通用的无回溯移入-归约分析技术，且和其它技术一样高效</li>
<li>可以尽早检测到错误</li>
<li>能分析的文法集合是LL(k)文法的超集</li>
</ul>
<h2 id="LR分析相关概念"><a href="#LR分析相关概念" class="headerlink" title="LR分析相关概念"></a>LR分析相关概念</h2><ul>
<li>移入-归约语法分析器如何知道何时该移入、 何时该归约呢？<ul>
<li>LR语法分析器试图用一些<strong>状态</strong>来表明我们在移进归约语法分析过程中所处的位置，从而做出移入-归约决定</li>
</ul>
</li>
<li>项的意义<ul>
<li>指明在语法分析过程中的给定点上，我们已经看到了一个产生式的哪些部分。或者说，如果我们想用这个产生式进行归约，还需要看到哪些文法符号</li>
</ul>
</li>
<li>项的集合（项集）对应于一个状态</li>
</ul>
<h2 id="LR-0-项"><a href="#LR-0-项" class="headerlink" title="LR(0)项"></a>LR(0)项</h2><ul>
<li>文法的一个产生式加上在其产生式体中某处的一个点<ul>
<li>A →.XYZ，A → X.YZ，A → XY.Z，A → XYZ.</li>
<li>注意：A → ε只对应一个项A →. </li>
</ul>
</li>
<li>直观含义<ul>
<li>项A → α.β表示已经扫描/归约到了α，并期望接下来的输入中经过扫描/归约得到β，然后把αβ归约到A</li>
<li>如果β为空，表示我们可以把α归约为A</li>
</ul>
</li>
<li>项也可以用一对整数表示<ul>
<li>(i,j)表示第i条规则，点位于右部第j个位置</li>
</ul>
</li>
</ul>
<h2 id="规范LR-0-项集族"><a href="#规范LR-0-项集族" class="headerlink" title="规范LR(0)项集族"></a>规范LR(0)项集族</h2><ul>
<li>规范LR(0)项集族提供构建LR(0)自动机的基础<ul>
<li>LR(0)自动机可用于做出语法分析决定</li>
<li>LR(0)自动机中每个状态代表了LR(0)项集族中的一个项集</li>
</ul>
</li>
</ul>
<h2 id="以项为基础构造自动机"><a href="#以项为基础构造自动机" class="headerlink" title="以项为基础构造自动机"></a>以项为基础构造自动机</h2><ul>
<li>构造以项为状态的自动机<ul>
<li>开始状态S’ →.S</li>
<li>转换<ul>
<li>A → α.Bβ到B →. γ有一个ε转换</li>
<li>从A → α.Xβ到A → αX.β有一个X转换</li>
</ul>
</li>
<li>接受状态：A → α.，即点在最后的项</li>
</ul>
</li>
</ul>
<h2 id="规范LR-0-项集族的构造"><a href="#规范LR-0-项集族的构造" class="headerlink" title="规范LR(0)项集族的构造"></a>规范LR(0)项集族的构造</h2><ul>
<li><p>三个概念</p>
<ul>
<li>增广文法</li>
<li>项集闭包：CLOSURE</li>
<li>GOTO</li>
</ul>
</li>
<li><p>增广文法</p>
<ul>
<li>G的增广文法G’是在G中增加新开始符号S’，并加入产生式S’→S而得到的</li>
<li>G’和G接受相同的语言，且按照S’→ S进行归约实际上就表示已经将输入符号串归约成为开始符号</li>
<li>引入的目的是告诉语法分析器何时宣布接受输入符号串，即用S’→S进行归约时，表明分析结束。 </li>
</ul>
</li>
<li><p>构造过程中用到的子函数</p>
<ul>
<li>CLOSURE(I)：I的项集闭包<ul>
<li>对应于DFA化算法的 ε-CLOSURE</li>
</ul>
</li>
<li>GOTO(I,X)：I的X后继<ul>
<li>对应于DFA化算法的MOVE(I,X)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="CLOSURE-I-的构造算法"><a href="#CLOSURE-I-的构造算法" class="headerlink" title="CLOSURE(I)的构造算法"></a>CLOSURE(I)的构造算法</h3><ul>
<li>如果I是文法G的一个项集，那么CLOSURE(I)就是根据下列规则从I构造得到的项集<ul>
<li>将I中的各个项加入到CLOSURE(I)中</li>
<li>如果A → α.Bβ在CLOSURE(I)中，那么对B的任意产生式B → γ，将B →.γ加到CLOSURE(I)中</li>
<li>不断重复第二步，直到收敛</li>
</ul>
</li>
<li>第二步的意义<ul>
<li>项A → α.Bβ表示期望在接下来的输入中归约到B</li>
<li>显然，要归约到B，首先要扫描归约到B的某个产生式的右部</li>
<li>因此对每个产生式B → γ，加入B →.γ<ul>
<li>表示它期望能够扫描归约到γ</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="项集闭包构造的例子"><a href="#项集闭包构造的例子" class="headerlink" title="项集闭包构造的例子"></a>项集闭包构造的例子</h4><ul>
<li>增广文法：<ul>
<li>E’ → E     E → E+T | T     T → T*F | F     F →(E) | id</li>
</ul>
</li>
<li>项集 I={[E’ →.E]} 的闭包<ul>
<li>[E’ →.E]在闭包中</li>
<li>[E →.E+T]，[E →.T]在闭包中</li>
<li>[T →.T*F]，[T →.F]在闭包中</li>
<li>[F →.(E)]，[F →.id]在闭包中<img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/59.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="LR-0-项集中的内核项和非内核项"><a href="#LR-0-项集中的内核项和非内核项" class="headerlink" title="LR(0)项集中的内核项和非内核项"></a>LR(0)项集中的内核项和非内核项</h2><ul>
<li>内核项：初始项S’ →.S、以及所有点不在最左边的项</li>
<li>非内核项：除了S’ →.S之外、点在最左边的项</li>
<li>由于表可能很庞大，实现算法时可以考虑只保存相应的非终结符号；甚至可以只保存内核项，而在要使用非内核项时调用CLOSURE函数重新计算</li>
</ul>
<h2 id="GOTO函数"><a href="#GOTO函数" class="headerlink" title="GOTO函数"></a>GOTO函数</h2><ul>
<li>I是一个项集，X是一个文法符号，GOTO(I,X)定义为I中所有形如的项[A → α·Xβ]所对应的项[A → αX·β]的集合的闭包<ul>
<li>根据项的历史-期望的含义，GOTO(I,X)表示读取输入中的X或者归约到一个X之后的情况</li>
<li>GOTO(I,X)定义了LR(0)自动机中状态I在X之上的转换</li>
</ul>
</li>
<li>例如<ul>
<li>I={[E’ → E.], [E → E.+T]}</li>
<li>GOTO(I,+)计算如下<ul>
<li>I中只有一个项的点后面跟着+，对应的项为[E → E+.T] ◼</li>
<li>CLOSURE({[E → E+.T]}) = {[E → E+.T]，[T →.T*F], [T→.F]， [F →.(E)]，[F →.id]}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="求LR-0-项集规范族的算法"><a href="#求LR-0-项集规范族的算法" class="headerlink" title="求LR(0)项集规范族的算法"></a>求LR(0)项集规范族的算法</h2><ul>
<li>为文法G构造LR(0)项集规范族C<img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/60.png" alt=""></li>
<li><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/61.png" alt=""></li>
</ul>
<h2 id="LR-0-自动机的构造"><a href="#LR-0-自动机的构造" class="headerlink" title="LR(0)自动机的构造"></a>LR(0)自动机的构造</h2><ul>
<li>构造方法<ul>
<li>规范LR(0)项集族中的项集可以作为LR(0)自动机的状态</li>
<li>GOTO(I,X)=J，则从I到J有一个标号为X的转换</li>
<li>初始状态为CLOSURE({S’ →.S})对应的项集</li>
<li>接受状态：包含形如A → α.的项集对应的状态</li>
</ul>
</li>
</ul>
<h2 id="LR-0-自动机的作用"><a href="#LR-0-自动机的作用" class="headerlink" title="LR(0)自动机的作用"></a>LR(0)自动机的作用</h2><ul>
<li>根据文法构造出LR(0)自动机，通过自动机的运行进行语法分析</li>
<li>假设文法符号串γ使LR(0)自动机从开始状态0运行到某个状态j，LR(0)自动机按照如下方式决定移入或归约<ul>
<li>如果下一个输入符号为a，且状态j上有a的转换，就移入a</li>
<li>否则就归约，状态j中的项会告诉我们使用那 个产生式进行归约</li>
</ul>
</li>
<li>假设文法符号串γ使LR(0)自动机从开始状态运行到状态（项集）j <ul>
<li>如果j中有一个形如A → α.的项，那么<ul>
<li>在γ之后添加一些终结符号可以得到一个最右句型</li>
<li>α是γ的后缀，且A → α是这个句型的句柄</li>
<li>表示可能找到了当前最右句型的句柄</li>
</ul>
</li>
<li>如果j中存在一个项B → α.Xβ，那么<ul>
<li>在γ之后添加Xβ，然后再添加一个终结符号串可得到一个最右句型</li>
<li>在这个句型中B → αXβ是句柄</li>
<li>此时表示还没有找到句柄，需要移入</li>
</ul>
</li>
</ul>
</li>
<li>LR(0)自动机的使用<ul>
<li>移入-归约时，LR(0)自动机被用于识别句型</li>
<li>已经归约/移入得到的文法符号序列对应于LR(0)自动机 的一条路径</li>
<li>如果路径到达接受状态，表明栈上端的某个符号串可能是句柄</li>
</ul>
</li>
<li>不需要每次用归约/移入得到的串来运行LR(0)自动机<ul>
<li>路径被放到栈中；且文法符号可以省略，因为由LR(0)状态可以确定相应文法符号</li>
<li>在移入后，根据原来的栈顶状态即可知道新的状态</li>
<li>在归约时，根据归约产生式的右部长度弹出相应状态，仍然可以根据此时的栈顶状态计算得到新状态</li>
</ul>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/62.png" alt=""></p>
<h2 id="LR语法分析器的结构"><a href="#LR语法分析器的结构" class="headerlink" title="LR语法分析器的结构"></a>LR语法分析器的结构</h2><ul>
<li>所有的分析器都使用相同的驱动程序</li>
<li>分析表随文法以及LR分析技术的不同而不同</li>
<li>栈中存放的是状态序列；可以由状态序列求出符号序列</li>
<li>分析程序根据栈顶状态、当前输入，通过分析表确定语法分析动作<br><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/63.png" alt=""></li>
</ul>
<h2 id="LR语法分析表的结构"><a href="#LR语法分析表的结构" class="headerlink" title="LR语法分析表的结构"></a>LR语法分析表的结构</h2><ul>
<li>两个部分：动作ACTION，转换GOTO</li>
<li>ACTION有两个参数：状态i、终结符号a<ul>
<li>移入j：j是一个状态。把j压入栈</li>
<li>归约A → β：把栈顶的β归约为A</li>
<li>接受：接受输入、完成分析</li>
<li>报错：在输入中发现语法错误</li>
</ul>
</li>
<li>状态集上的GOTO函数<img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/64.png" alt=""></li>
</ul>
<h2 id="LR语法分析器的格局"><a href="#LR语法分析器的格局" class="headerlink" title="LR语法分析器的格局"></a>LR语法分析器的格局</h2><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/65.png" alt=""></p>
<h2 id="LR语法分析器的行为"><a href="#LR语法分析器的行为" class="headerlink" title="LR语法分析器的行为"></a>LR语法分析器的行为</h2><p><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/66.png" alt=""></p>
<h2 id="LR语法分析算法"><a href="#LR语法分析算法" class="headerlink" title="LR语法分析算法"></a>LR语法分析算法</h2><ul>
<li>输入：文法G的LR语法分析表，输入串w</li>
<li>输出：如果w在L(G)中，输出最左归约步骤（最右推导的反向过程），否则输出错误指示</li>
<li>算法<img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/67.png" alt=""></li>
</ul>
<h1 id="SLR分析表构造"><a href="#SLR分析表构造" class="headerlink" title="SLR分析表构造"></a>SLR分析表构造</h1><h2 id="SLR分析表构造-1"><a href="#SLR分析表构造-1" class="headerlink" title="SLR分析表构造"></a>SLR分析表构造</h2><ul>
<li>SLR: Simple LR</li>
<li>以LR(0)项和LR(0)自动机为基础，基于文法G的规范项集族C和GOTO函数就可以构造出SLR的语法分析表</li>
</ul>
<h2 id="SLR分析表构造算法"><a href="#SLR分析表构造算法" class="headerlink" title="SLR分析表构造算法"></a>SLR分析表构造算法</h2><ul>
<li>输入：一个增广文法G’</li>
<li>输出：G’的SLR语法分析表函数ACTION和GOTO</li>
<li>方法：<img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/courses/Compilers%40NJUSE/Chapter04/68.png" alt=""></li>
</ul>
<h2 id="SLR的原理"><a href="#SLR的原理" class="headerlink" title="SLR的原理"></a>SLR的原理</h2><h3 id="可行前缀"><a href="#可行前缀" class="headerlink" title="可行前缀"></a>可行前缀</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://rashawnxue.github.io">RashawnXue</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://rashawnxue.github.io/2023/04/18/courses/NJUSE/Compilers@NJUSE/Compilers-NJUSE-Chapter04/">http://rashawnxue.github.io/2023/04/18/courses/NJUSE/Compilers@NJUSE/Compilers-NJUSE-Chapter04/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://rashawnxue.github.io" target="_blank">Rashawn's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/icon/avatar-icon-square.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/18/courses/NJUSE/Compilers@NJUSE/Compilers-NJUSE-Chapter05/" title="Compilers@NJUSE-Chapter05 Syntax-Directed Translation"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Compilers@NJUSE-Chapter05 Syntax-Directed Translation</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/18/courses/NJUSE/OS@NJUSE/OS-NJUSE-Chapter04-md/" title="OS@NJUSE-Chapter04.md"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">OS@NJUSE-Chapter04.md</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://rashawn-blog.oss-cn-shanghai.aliyuncs.com/blog/icon/avatar-icon-square.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">RashawnXue</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/RashawnXue"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/RashawnXue" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:ruichenxue@smail.nju.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">语法分析器的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">文法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E8%A1%A8%E6%80%A7%E6%96%87%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">代表性文法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LR%E6%96%87%E6%B3%95%E7%B1%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">LR文法类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LL%E6%96%87%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">LL文法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">上下文无关文法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">上下文无关文法的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%9C%89%E5%85%B3%E6%96%87%E6%B3%95%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">上下文有关文法与上下文无关文法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95%E4%BE%8B%E5%AD%90"><span class="toc-number">2.2.1.</span> <span class="toc-text">一个简单的上下文无关文法例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E6%9C%89%E5%85%B3%E6%96%87%E6%B3%95%E4%BE%8B%E5%AD%90"><span class="toc-number">2.2.2.</span> <span class="toc-text">一个简单的上下文有关文法例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E6%8F%8F%E8%BF%B0%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%96%87%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">用于描述算术表达式的文法定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC"><span class="toc-number">2.3.</span> <span class="toc-text">推导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%A5%E5%9E%8B-%E5%8F%A5%E5%AD%90-%E8%AF%AD%E8%A8%80"><span class="toc-number">2.4.</span> <span class="toc-text">句型&#x2F;句子&#x2F;语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.</span> <span class="toc-text">推导的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E7%BB%88%E7%BB%93%E7%AC%A6%E5%8F%B7%E7%9A%84%E6%9B%BF%E6%8D%A2%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.6.</span> <span class="toc-text">非终结符号的替换顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91"><span class="toc-number">2.7.</span> <span class="toc-text">语法分析树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E5%92%8C%E8%AF%AD%E6%B3%95%E6%A0%91"><span class="toc-number">2.8.</span> <span class="toc-text">推导和语法树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E4%B9%89%E6%80%A7%E6%96%87%E6%B3%95"><span class="toc-number">2.9.</span> <span class="toc-text">二义性文法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-number">2.10.</span> <span class="toc-text">二义性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E5%8F%8A%E5%85%B6%E7%94%9F%E6%88%90%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="toc-number">2.11.</span> <span class="toc-text">文法及其生成的语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E6%96%87%E6%B3%95%E7%94%9F%E6%88%90%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="toc-number">2.12.</span> <span class="toc-text">验证文法生成的语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">2.13.</span> <span class="toc-text">词法分析与语法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E6%AF%94%E8%BE%83"><span class="toc-number">2.13.1.</span> <span class="toc-text">二者比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">2.14.</span> <span class="toc-text">补充</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E2%9C%A8"><span class="toc-number">2.15.</span> <span class="toc-text">上下文无关文法和正则表达式✨</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text">文法的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E6%96%87%E6%B3%95%E7%9A%84%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-number">3.1.</span> <span class="toc-text">消除文法的二义性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E5%B7%A6%E9%80%92%E5%BD%92"><span class="toc-number">3.2.</span> <span class="toc-text">消除左递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E5%B7%A6%E9%80%92%E5%BD%92%E7%9A%84%E6%B6%88%E9%99%A4"><span class="toc-number">3.3.</span> <span class="toc-text">立即左递归的消除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E5%A4%9A%E6%AD%A5%E5%B7%A6%E9%80%92%E5%BD%92"><span class="toc-number">3.4.</span> <span class="toc-text">消除多步左递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.1.</span> <span class="toc-text">消除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E7%9A%84%E5%B7%A6%E9%80%92%E5%BD%92%E6%B6%88%E9%99%A4%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.2.</span> <span class="toc-text">通用的左递归消除方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E5%B7%A6%E5%85%AC%E5%9B%A0%E5%AD%90"><span class="toc-number">3.5.</span> <span class="toc-text">提取左公因子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E5%B7%A6%E5%85%AC%E5%9B%A0%E5%AD%90%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.1.</span> <span class="toc-text">提取左公因子算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E8%AF%AD%E8%A8%80%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">3.6.</span> <span class="toc-text">非上下文无关语言的构造</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">自顶向下语法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF"><span class="toc-number">4.1.</span> <span class="toc-text">自顶向下分析技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-1"><span class="toc-number">4.2.</span> <span class="toc-text">自顶向下语法分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">递归下降过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="toc-number">4.4.</span> <span class="toc-text">预测分析法简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF"><span class="toc-number">4.5.</span> <span class="toc-text">预测分析技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FIRST%E5%92%8CFOLLOW"><span class="toc-number">4.6.</span> <span class="toc-text">FIRST和FOLLOW</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FIRST-alpha"><span class="toc-number">4.7.</span> <span class="toc-text">$FIRST(\alpha)$</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#First%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">4.7.1.</span> <span class="toc-text">First的计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FOLLOW-%E5%87%BD%E6%95%B0"><span class="toc-number">4.8.</span> <span class="toc-text">$FOLLOW$函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FOLLOW%E8%AE%A1%E7%AE%97"><span class="toc-number">4.8.1.</span> <span class="toc-text">FOLLOW计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LL-1-%E6%96%87%E6%B3%95"><span class="toc-number">4.9.</span> <span class="toc-text">LL(1)文法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LL-1-%E6%96%87%E6%B3%95%E7%9A%84%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF"><span class="toc-number">4.10.</span> <span class="toc-text">LL(1)文法的预测分析技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E8%A1%A8%E6%9E%84%E9%80%A0"><span class="toc-number">4.11.</span> <span class="toc-text">预测分析表构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-number">4.12.</span> <span class="toc-text">预测分析方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E4%B9%89%E6%80%A7%E6%96%87%E6%B3%95%E7%9A%84%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E8%A1%A8"><span class="toc-number">4.13.</span> <span class="toc-text">二义性文法的预测分析表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.14.</span> <span class="toc-text">非递归的预测分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF"><span class="toc-number">4.14.1.</span> <span class="toc-text">非递归的预测分析技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%A1%A8%E9%A9%B1%E5%8A%A8%E7%9A%84%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-number">4.14.2.</span> <span class="toc-text">分析表驱动的预测分析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E9%A9%B1%E5%8A%A8%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E9%A2%84%E6%B5%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">4.14.3.</span> <span class="toc-text">表驱动的非递归的预测语法分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">自底向上语法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E7%BA%A6"><span class="toc-number">5.1.1.</span> <span class="toc-text">归约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E7%BA%A6%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">归约的例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E7%BA%A6"><span class="toc-number">5.1.2.</span> <span class="toc-text">规约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%EF%BC%9A%E5%8F%A5%E5%9E%8B-%E5%8F%A5%E5%AD%90-%E8%AF%AD%E8%A8%80"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">回顾：句型&#x2F;句子&#x2F;语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">句柄</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84%E5%89%AA%E6%9E%9D"><span class="toc-number">5.1.3.</span> <span class="toc-text">句柄剪枝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%85%A5-%E5%BD%92%E7%BA%A6%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6"><span class="toc-number">5.2.</span> <span class="toc-text">移入-归约语法分析框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%85%A5-%E5%BD%92%E7%BA%A6%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF"><span class="toc-number">5.2.1.</span> <span class="toc-text">移入-归约分析技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%88%86%E6%9E%90%E5%8A%A8%E4%BD%9C"><span class="toc-number">5.2.2.</span> <span class="toc-text">主要分析动作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%B2%E7%AA%81"><span class="toc-number">5.3.</span> <span class="toc-text">冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E8%BF%9B-%E5%BD%92%E7%BA%A6%E5%86%B2%E7%AA%81"><span class="toc-number">5.3.1.</span> <span class="toc-text">移进&#x2F;归约冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E7%BA%A6-%E5%BD%92%E7%BA%A6%E5%86%B2%E7%AA%81"><span class="toc-number">5.3.2.</span> <span class="toc-text">归约&#x2F;归约冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.3.</span> <span class="toc-text">解决冲突问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LR%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF"><span class="toc-number">6.</span> <span class="toc-text">LR语法分析技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LR%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">6.1.</span> <span class="toc-text">LR语法分析器的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LR%E5%88%86%E6%9E%90%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">6.2.</span> <span class="toc-text">LR分析相关概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LR-0-%E9%A1%B9"><span class="toc-number">6.3.</span> <span class="toc-text">LR(0)项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E8%8C%83LR-0-%E9%A1%B9%E9%9B%86%E6%97%8F"><span class="toc-number">6.4.</span> <span class="toc-text">规范LR(0)项集族</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E9%A1%B9%E4%B8%BA%E5%9F%BA%E7%A1%80%E6%9E%84%E9%80%A0%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">6.5.</span> <span class="toc-text">以项为基础构造自动机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E8%8C%83LR-0-%E9%A1%B9%E9%9B%86%E6%97%8F%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">6.6.</span> <span class="toc-text">规范LR(0)项集族的构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CLOSURE-I-%E7%9A%84%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95"><span class="toc-number">6.6.1.</span> <span class="toc-text">CLOSURE(I)的构造算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E9%9B%86%E9%97%AD%E5%8C%85%E6%9E%84%E9%80%A0%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">6.6.1.1.</span> <span class="toc-text">项集闭包构造的例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LR-0-%E9%A1%B9%E9%9B%86%E4%B8%AD%E7%9A%84%E5%86%85%E6%A0%B8%E9%A1%B9%E5%92%8C%E9%9D%9E%E5%86%85%E6%A0%B8%E9%A1%B9"><span class="toc-number">6.7.</span> <span class="toc-text">LR(0)项集中的内核项和非内核项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GOTO%E5%87%BD%E6%95%B0"><span class="toc-number">6.8.</span> <span class="toc-text">GOTO函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82LR-0-%E9%A1%B9%E9%9B%86%E8%A7%84%E8%8C%83%E6%97%8F%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">6.9.</span> <span class="toc-text">求LR(0)项集规范族的算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LR-0-%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">6.10.</span> <span class="toc-text">LR(0)自动机的构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LR-0-%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">6.11.</span> <span class="toc-text">LR(0)自动机的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.11.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LR%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">6.12.</span> <span class="toc-text">LR语法分析器的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LR%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">6.13.</span> <span class="toc-text">LR语法分析表的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LR%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E6%A0%BC%E5%B1%80"><span class="toc-number">6.14.</span> <span class="toc-text">LR语法分析器的格局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LR%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">6.15.</span> <span class="toc-text">LR语法分析器的行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LR%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">6.16.</span> <span class="toc-text">LR语法分析算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SLR%E5%88%86%E6%9E%90%E8%A1%A8%E6%9E%84%E9%80%A0"><span class="toc-number">7.</span> <span class="toc-text">SLR分析表构造</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SLR%E5%88%86%E6%9E%90%E8%A1%A8%E6%9E%84%E9%80%A0-1"><span class="toc-number">7.1.</span> <span class="toc-text">SLR分析表构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SLR%E5%88%86%E6%9E%90%E8%A1%A8%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text">SLR分析表构造算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SLR%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">SLR的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A1%8C%E5%89%8D%E7%BC%80"><span class="toc-number">7.3.1.</span> <span class="toc-text">可行前缀</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/18/courses/NJUSE/SECII@NJUSE/SECII-NJUSE-Chapter09/" title="SECII@NJUSE-Chapter09 软件体系结构基础">SECII@NJUSE-Chapter09 软件体系结构基础</a><time datetime="2023-04-18T12:07:18.000Z" title="发表于 2023-04-18 20:07:18">2023-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/18/courses/NJUSE/SECII@NJUSE/SECII-NJUSE-Chapter08/" title="SECII@NJUSE-Chapter08 软件设计基础">SECII@NJUSE-Chapter08 软件设计基础</a><time datetime="2023-04-18T12:07:13.000Z" title="发表于 2023-04-18 20:07:13">2023-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/18/courses/NJUSE/SECII@NJUSE/SECII-NJUSE-Chapter07/" title="SECII@NJUSE-Chapter07 需求文档化与验证">SECII@NJUSE-Chapter07 需求文档化与验证</a><time datetime="2023-04-18T12:07:05.000Z" title="发表于 2023-04-18 20:07:05">2023-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/18/courses/NJUSE/SECII@NJUSE/SECII-NJUSE-Chapter06/" title="SECII@NJUSE-Chapter06 需求分析方法">SECII@NJUSE-Chapter06 需求分析方法</a><time datetime="2023-04-18T12:07:04.000Z" title="发表于 2023-04-18 20:07:04">2023-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/18/courses/NJUSE/SECII@NJUSE/SECII-NJUSE-Chapter05/" title="SECII@NJUSE-Chapter05 需求基础">SECII@NJUSE-Chapter05 需求基础</a><time datetime="2023-04-18T12:07:03.000Z" title="发表于 2023-04-18 20:07:03">2023-04-18</time></div></div></div></div></div></div></main><footer id="footer" style="background: url"><div id="footer-wrap"><div class="copyright">&copy;2023 By RashawnXue</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">O ever youthful. O ever weeping.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script src="/js/rphoto.js"></script><script data-pjax>obcboPic()</script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>